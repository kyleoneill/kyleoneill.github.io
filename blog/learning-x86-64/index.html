<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="The developer portfolio for Kyle O&#x27;Neill">
        <meta name="author" content="Kyle O&#x27;Neill">
       
        <!-- favicon -->
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="theme-color" content="#ffffff">

        <!-- fonts and styles -->
        <link href="https://fonts.googleapis.com/css?family=Rubik:400,700" rel="stylesheet">
        <link href="https://kyleoneill.dev/style.css" rel="stylesheet">

        <title>
            
                Learning x86-64
            
        </title>
    </head>
    <body>
        <div class="section header">
            <div class="logo">
                <a href="/" class="logo-image" width="100"></a>
            </div>
            <div class="links">
                
                
                    <a href="https://kyleoneill.dev/about/">About</a>
                
                    <a href="https://kyleoneill.dev/resume/">Resume</a>
                
                
                    
                    <a href="https://kyleoneill.dev/blog/">Blog</a>
                
            </div>
            <!-- search would go here -->
        </div>
        
<div class="section title">
    Learning x86-64
    <div class="subtitle">
        November  8, 2023
    </div>
</div>
<div class="section content">
    <h1 id="let-s-learn-x86-64">Let's learn x86-64</h1>
<p>I have recently been playing <a rel="external" href="https://en.wikipedia.org/wiki/Shenzhen_I/O">Shenzhen I/O</a> and it reminded me of when I took a course in college where I learned some basic <a rel="external" href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS</a>. I figured it might be fun to learn some more assembly, specifically one that is more popular in use. I figured I would try to make something that sounded "simple", a program in x86-64 that allows a user to input two numbers which are then added together and displayed.</p>
<h1 id="adding-is-supposed-to-be-easy">Adding is supposed to be easy</h1>
<p>This idea in a higher level language is extremely simple and pretty commonly used when first learning a language or learning programming. The following is an example of what we want to do, written in Rust.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="rust"><span class="giallo-l"><span style="color: #569CD6;">use</span><span> std</span><span style="color: #D4D4D4;">::</span><span>io</span><span style="color: #D4D4D4;">::</span><span>{stdin, stdout,</span><span style="color: #4EC9B0;"> Write</span><span>};</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span style="color: #569CD6;">fn</span><span style="color: #DCDCAA;"> main</span><span>() {</span></span>
<span class="giallo-l"><span style="color: #6A9955;">    // Define a buffer to hold our user input</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let mut</span><span style="color: #9CDCFE;"> input</span><span style="color: #D4D4D4;"> =</span><span style="color: #4EC9B0;"> String</span><span style="color: #D4D4D4;">::</span><span style="color: #DCDCAA;">new</span><span>();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span style="color: #6A9955;">    // Get a number from our user</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">    print!</span><span>(</span><span style="color: #CE9178;">&quot;Enter a number: &quot;</span><span>);</span></span>
<span class="giallo-l"><span>    std</span><span style="color: #D4D4D4;">::</span><span>io</span><span style="color: #D4D4D4;">::</span><span style="color: #DCDCAA;">stdout</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">flush</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">unwrap</span><span>();</span><span style="color: #6A9955;"> // Flush the buffer to output as print! doesn&#39;t do that for performance</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">    stdin</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">read_line</span><span>(</span><span style="color: #D4D4D4;">&amp;</span><span style="color: #569CD6;">mut</span><span style="color: #9CDCFE;"> input</span><span>)</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">expect</span><span>(</span><span style="color: #CE9178;">&quot;Didn&#39;t get a string&quot;</span><span>);</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let</span><span style="color: #9CDCFE;"> input_without_newline</span><span style="color: #D4D4D4;"> = &amp;</span><span style="color: #9CDCFE;">input</span><span>[</span><span style="color: #D4D4D4;">..</span><span style="color: #9CDCFE;">input</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">len</span><span>()</span><span style="color: #D4D4D4;"> -</span><span style="color: #B5CEA8;"> 1</span><span>];</span><span style="color: #6A9955;"> // We need to remove the newline at the end of the string</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let</span><span style="color: #9CDCFE;"> first_num</span><span style="color: #D4D4D4;"> =</span><span style="color: #9CDCFE;"> input_without_newline</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">parse</span><span style="color: #D4D4D4;">::</span><span>&lt;</span><span style="color: #4EC9B0;">i32</span><span>&gt;()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">unwrap</span><span>();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span style="color: #6A9955;">    // Reset the buffer value and get a second number from our user</span></span>
<span class="giallo-l"><span style="color: #9CDCFE;">    input</span><span style="color: #D4D4D4;"> =</span><span style="color: #CE9178;"> &quot;&quot;</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">to_owned</span><span>();</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">    print!</span><span>(</span><span style="color: #CE9178;">&quot;Enter a second number: &quot;</span><span>);</span></span>
<span class="giallo-l"><span>    std</span><span style="color: #D4D4D4;">::</span><span>io</span><span style="color: #D4D4D4;">::</span><span style="color: #DCDCAA;">stdout</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">flush</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">unwrap</span><span>();</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">    stdin</span><span>()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">read_line</span><span>(</span><span style="color: #D4D4D4;">&amp;</span><span style="color: #569CD6;">mut</span><span style="color: #9CDCFE;"> input</span><span>)</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">expect</span><span>(</span><span style="color: #CE9178;">&quot;Didn&#39;t get a string&quot;</span><span>);</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let</span><span style="color: #9CDCFE;"> input_without_newline</span><span style="color: #D4D4D4;"> = &amp;</span><span style="color: #9CDCFE;">input</span><span>[</span><span style="color: #D4D4D4;">..</span><span style="color: #9CDCFE;">input</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">len</span><span>()</span><span style="color: #D4D4D4;"> -</span><span style="color: #B5CEA8;"> 1</span><span>];</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let</span><span style="color: #9CDCFE;"> second_num</span><span style="color: #D4D4D4;"> =</span><span style="color: #9CDCFE;"> input_without_newline</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">parse</span><span style="color: #D4D4D4;">::</span><span>&lt;</span><span style="color: #4EC9B0;">i32</span><span>&gt;()</span><span style="color: #D4D4D4;">.</span><span style="color: #DCDCAA;">unwrap</span><span>();</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span style="color: #6A9955;">    // Add the numbers together and display them</span></span>
<span class="giallo-l"><span style="color: #569CD6;">    let</span><span style="color: #9CDCFE;"> result</span><span style="color: #D4D4D4;"> =</span><span style="color: #9CDCFE;"> first_num</span><span style="color: #D4D4D4;"> +</span><span style="color: #9CDCFE;"> second_num</span><span>;</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">    println!</span><span>(</span><span style="color: #CE9178;">&quot;Your added numbers: {}&quot;</span><span>,</span><span style="color: #9CDCFE;"> result</span><span>);</span></span>
<span class="giallo-l"><span>}</span></span></code></pre>
<p>This program prompts a user to enter two numbers and prints their sum. The components of this program which we care about are:</p>
<ol>
<li>Create some buffer to hold user input</li>
<li>Prompt the user to enter a number</li>
<li>Read user text input</li>
<li>Convert the user text input into an integer, removing any excess non-int data (like a newline)</li>
<li>Repeat the previous three steps to get a second integer</li>
<li>Add our two numbers together</li>
<li>Convert our sum into a string and display it to the user</li>
</ol>
<h1 id="hello-world">Hello, World!</h1>
<p>We will be using the <a rel="external" href="https://www.nasm.us/">NASM</a> assembler. Before writing our adding program, let's make a Hello World so we have a baseline program to build from.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>; I am a comment</span></span>
<span class="giallo-l"><span>section .data</span></span>
<span class="giallo-l"><span>    msg db &quot;Hello world&quot;,13,10</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>section .text</span></span>
<span class="giallo-l"><span>    global _main</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>_main:</span></span>
<span class="giallo-l"><span>    mov rax, 1</span></span>
<span class="giallo-l"><span>    mov rdi, 1</span></span>
<span class="giallo-l"><span>    mov rsi, msg</span></span>
<span class="giallo-l"><span>    mov rdx, 13</span></span>
<span class="giallo-l"><span>    syscall</span></span>
<span class="giallo-l"><span>    jmp .exit</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>.exit:</span></span>
<span class="giallo-l"><span>    mov rax, 60</span></span>
<span class="giallo-l"><span>    mov rdi, 0</span></span>
<span class="giallo-l"><span>    syscall</span></span></code></pre>
<p>This program is made to be run on Linux, assembly is platform specific.</p>
<h2 id="sections">Sections</h2>
<p>There are two "sections" we care about right now, <code>.data</code> and <code>.text</code>.</p>
<p>The data section is where we declare static variables. Here, we define a <code>msg</code> variable which will hold the string <code>"Hello world"</code>. The <code>13,10</code> portion of our string
corresponds with the ASCII characters for "carriage return" and "line feed". This is akin to writing <code>"Hello world\r\n"</code> in a language like Python. The <code>db</code>
stands for "define bytes" and allocates bytes to hold our string value.</p>
<p>The text section is where we actually write our program. Our text section begins with <code>global _main</code>, which defines the entry-point for our program.</p>
<h2 id="comments">Comments</h2>
<p>Comments in nasm begin with <code>;</code>.</p>
<h2 id="instructions">Instructions</h2>
<p>Our <code>_main</code> function contains four <code>mov</code> instructions, a syscall, and then a jump to another area in the assembly. The <code>mov</code> instruction takes the format of <code>MOV &lt;destination&gt; &lt;source&gt;</code>, where we are moving a value from the source (which can be a static value, variable, or another register) into the destination. In the <code>mov rax, 1</code> instruction we are moving the static value <code>1</code> into the <code>rax</code> register. A register is a tiny piece of memory your CPU can access very quickly. A list of registers can be found in many places on the internet, <a rel="external" href="https://web.stanford.edu/class/cs107/guide/x86-64.html">this Stanford resource</a> being an example.</p>
<h2 id="what-is-a-syscall">What is a syscall?</h2>
<p>When working with assembly, we work in a low level space where privilege is an important concept and we need to care about "userspace" and "kernel-space". Our program runs in "userspace" and lacks permissions to do many of the operations we want to do, like write to an output and get user input. We need to ask the OS to do those things for us. A syscall suspends our program and returns control to the OS, which will then examine pre-determined registers for data which tells it what we want it to do.</p>
<p>The <code>rax</code> register tells the OS what function to run when we make a syscall and registers <code>rdi</code>, <code>rsi</code>, and <code>rdx</code> provide three arguments to that function. Here we move 1 into <code>rax</code>, which tells the OS that we want to call <code>sys_write</code>. We can see in the <a rel="external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c">Linux kernel code</a> that <code>sys_write</code> expects three arguments: a file descriptor, a buffer, and a size. We move 1 into <code>rdi</code> to indicate our file descriptor (0 is std_input, 1 is std_output, 2 is std_error), our string variable into <code>rsi</code>, and the size of our string into <code>rdx</code>. We then make a syscall, which suspends our program and causes the OS to read those four registers, print our string to the screen, and then resume our program.</p>
<h2 id="ending-our-program">Ending our program</h2>
<p>After we print "Hello world" we jump to the <code>.exit</code> label and make another syscall. We move 60 into <code>rax</code>, which tells the OS that we want to exit our program. The exit takes a single argument, the exit code. Our program has run successfully so we will move a 0 into <code>rdi</code> to indicate a successful status. Once we syscall here, our program ends.</p>
<h2 id="actually-running-the-program">Actually running the program</h2>
<p>We can run our program by creating an object file and then linking the two to create a binary. The below will create an elf64 binary file named <code>hello</code> from a <code>hello.asm</code> assembly program which you can run on Linux:</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="shellscript"><span class="giallo-l"><span style="color: #DCDCAA;">nasm</span><span style="color: #CE9178;"> -f elf64 -o hello.o hello.asm</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">ld</span><span style="color: #CE9178;"> -o hello hello.o</span></span></code></pre><h1 id="hello-math">Hello, Math!</h1>
<p>Now we want to translate the Rust code from earlier into an assembly program.</p>
<h2 id="create-a-buffer-to-hold-user-input">Create a buffer to hold user input</h2>
<p>We are going to define a variable to use as a buffer for our user input, but we are going to use a new section to define it. In addition to the data and text sections, we can also define a "block starting symbol" section where we can declare a variable which has not been assigned a value. We are going to define a buffer which can hold 64 bytes, an arbitrary and large size.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>section .bss</span></span>
<span class="giallo-l"><span>    read_buffer resb 64</span></span></code></pre><h2 id="prompt-the-user-to-enter-a-number">Prompt the user to enter a number</h2>
<p>This is the easy bit, as we already figured out how to do this in our "Hello, World!" example. Here we can define two prompt strings in our data section and then print to the screen in our text section.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>section .data</span></span>
<span class="giallo-l"><span>    first_msg db &quot;Enter first number: &quot;</span></span>
<span class="giallo-l"><span>    first_msg_len equ $ - first_msg ; This variable is going to store the length of our string, for ease of use</span></span>
<span class="giallo-l"><span>    second_msg db &quot;Enter second number: &quot;</span></span>
<span class="giallo-l"><span>    second_msg_len equ $ - second_msg</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>section .text</span></span>
<span class="giallo-l"><span>    global _start</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>_start:</span></span>
<span class="giallo-l"><span>    ; Ask our user to enter a number</span></span>
<span class="giallo-l"><span>    mov rax, 1</span></span>
<span class="giallo-l"><span>    mov rdi, 1</span></span>
<span class="giallo-l"><span>    mov rsi, first_msg</span></span>
<span class="giallo-l"><span>    mov rdx, first_msg_len</span></span>
<span class="giallo-l"><span>    syscall</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; We will get user input here later</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Repeat the above with our second_message variables</span></span>
<span class="giallo-l"><span>    ; ...</span></span></code></pre><h2 id="read-user-text-input">Read user text input</h2>
<p>We are going to make a new function to perform this action to aid both in readability and to allow us to re-use it. We are also going to use a new syscall with code 0, <code>sys_read</code>. <code>sys_read</code> takes three arguments, a file descriptor (see above), a buffer, and a buffer size. <code>sys_read</code> also has a return value which we care about, the number of bytes written. When a syscall returns a value, that value will be placed in the <code>rax</code> register by the OS before control is returned to our program.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>;...</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>_start:</span></span>
<span class="giallo-l"><span>    ; ...</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    call _read_number</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    ; ...</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>_read_number:</span></span>
<span class="giallo-l"><span>    ; Function prologue</span></span>
<span class="giallo-l"><span>    push rbp</span></span>
<span class="giallo-l"><span>    mov rbp, rsp</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; call &quot;sys_read&quot;</span></span>
<span class="giallo-l"><span>    mov rax, 0</span></span>
<span class="giallo-l"><span>    mov rdi, 0 ; file_descriptor 0 is std_input</span></span>
<span class="giallo-l"><span>    mov rsi, read_buffer</span></span>
<span class="giallo-l"><span>    mov rdx, 20 ; We are giving an arbitrarily large buffer size here</span></span>
<span class="giallo-l"><span>    syscall</span></span>
<span class="giallo-l"><span>    </span></span>
<span class="giallo-l"><span>    ; Convert our text into a number and store it in r12</span></span>
<span class="giallo-l"><span>    ; This will be explained in the next section</span></span>
<span class="giallo-l"><span>    call _read_buffer_to_number</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Function epilogue</span></span>
<span class="giallo-l"><span>    mov rsp, rbp</span></span>
<span class="giallo-l"><span>    pop rbp</span></span>
<span class="giallo-l"><span>    ret</span></span></code></pre>
<p>The <code>call</code> and <code>ret</code> instructions here manage a pointer which tells the CPU where it is executing in the program. When we <code>call</code>, the address of the next instruction is stored on the stack so we know where to come back to and resume execution when our function finishes. When we call <code>ret</code>, the top value on the stack is read and replaces the instruction pointer. It is typical when writing a function in assembly to include a "prologue" and "epilogue" before and after your functions main code so, if your function uses the stack, you don't cause a problem when <code>ret</code> tries to grab the address left for it by <code>call</code>. This program is not using the stack, but since the purpose of this exercise is to learn, the prologue/epilogue are included anyway.</p>
<p>After we syscall, the OS will fill our <code>read_buffer</code> with whatever the user inputs and store the number of bytes written into <code>rax.</code></p>
<h2 id="convert-the-user-text-into-an-integer">Convert the user text into an integer</h2>
<p>If we try to do any math with the number input by a user here, the output will not make sense. If our user enters <code>1</code> then the integer value stored in our <code>read_buffer</code> is going to be <code>2609</code> in decimal, or <code>0x0A31</code> in hex. On a little endian machine like mine this corresponds to the ASCII value for "1" (<code>49</code> in decimal, <code>0x31</code> in hex) followed by a line feed (<code>10</code> in decimal, <code>0xA</code> in hex). In order to treat the input like a number so we can do math with it, we need to remove the linefeed and convert the ASCII number into an integer number.</p>
<p>The process of converting our digits is two-fold. First, we first must take an ASCII digit and subtract 48 from it. Since the ASCII value of "1" is 49, subtracting 48 will bring the value to what we expect it to be. Second, we need to accumulate our digits. If our user enters a number with more than one digit, like 105, then every time we read a digit we must multiply our accumulated number by 10 before adding a digit.</p>
<p>The following was my first pass at this, but it contains a bug that prevents it from working as expected.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>_read_buffer_to_number:</span></span>
<span class="giallo-l"><span>    ; rax here is the number of bytes that we just wrote to read_buffer</span></span>
<span class="giallo-l"><span>    mov r12, 0 ; Our accumulator</span></span>
<span class="giallo-l"><span>    mov r10, 0 ; Loop counter</span></span>
<span class="giallo-l"><span>    .loop:</span></span>
<span class="giallo-l"><span>        ; The instruction below this comment causes a bug</span></span>
<span class="giallo-l"><span>        mov r9, [read_buffer + r10] ; mov char from read_buffer into a register</span></span>
<span class="giallo-l"><span>        sub r9, 48 ; subtract 48 (converting ASCII into decimal)</span></span>
<span class="giallo-l"><span>        ; fold the number into an accumulator</span></span>
<span class="giallo-l"><span>        ;    acc = acc x 10</span></span>
<span class="giallo-l"><span>        ;    acc = acc + new_char</span></span>
<span class="giallo-l"><span>        imul r12, 10</span></span>
<span class="giallo-l"><span>        add r12, r9</span></span>
<span class="giallo-l"><span>        add r10, 1 ; Increment loop counter</span></span>
<span class="giallo-l"><span>        mov r11, r10 ; Set a temporary register we will use for comparison</span></span>
<span class="giallo-l"><span>        add r11, 1 ; Add 1 to tmp register, this is to account for the newline we want to ignore from our input</span></span>
<span class="giallo-l"><span>        cmp r11, rax ; Compare how many digits we have read to rax, which holds how many characters were written</span></span>
<span class="giallo-l"><span>        jl .loop ; Loop again if we have not read all digits</span></span>
<span class="giallo-l"><span>    ; r12, the accumulator, is our return value</span></span>
<span class="giallo-l"><span>    ret</span></span></code></pre>
<p>The snippet above contains a <code>loop</code> label representing a loop, the <code>r12</code> register representing the number we are accumulating (and our output), and a loop counter stored in the <code>r10</code> register. In our loop we move data out of the <code>read_buffer</code> and into the <code>r9</code> register, subtract 48 to convert the value from an ASCII digit to a number, and fold the number into our accumulator. We then increment our loop counter and compare it to <code>rax</code> which contains the number of bytes written by the user in the previous syscall. If our loop counter is less than the number of bytes written, we jump to the <code>.loop</code> label to read another digit.</p>
<h2 id="debugging-assembly">Debugging assembly</h2>
<p>The <code>_read_buffer_to_number</code> function is very close to functional but contains a bug that stops it from doing what we expect it to. This is a good time to learn how to debug an assembly program. Higher level languages have very convenient debuggers built into IDEs and the classic <code>print("I am here")</code> if one does not want to use a debugger. Neither of these are viable strategies in our assembler. We are going to use <code>gdb</code> to debug. To start, we need to generate debug symbols. We're going to change how we were generating our binary file like so:</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="shellscript"><span class="giallo-l"><span style="color: #DCDCAA;">nasm</span><span style="color: #CE9178;"> -f elf64 -gdwarf -o add.o add.asm</span></span>
<span class="giallo-l"><span style="color: #DCDCAA;">ld</span><span style="color: #CE9178;"> -o add add.o</span></span></code></pre>
<p>Next, run <code>gdb</code> with the binary as an argument:</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="shellscript"><span class="giallo-l"><span style="color: #DCDCAA;">gdb</span><span style="color: #CE9178;"> ./add</span></span></code></pre>
<p>We want to debug the _read_buffer_to_number function, so add a breakpoint like:</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="shellscript"><span class="giallo-l"><span>(</span><span style="color: #DCDCAA;">gdb</span><span>)</span><span style="color: #DCDCAA;"> b</span><span style="color: #CE9178;"> _read_buffer_to_number</span></span></code></pre>
<p>Then enter "run" to begin execution of the program. After we enter our number, the breakpoint will trigger. Entering "next" will cause the debugger to step forward by one instruction, we will step until we run the <code>mov r9, [read_buffer + r10]</code> instruction. After that instruction is run we can enter "info registers" to display all of our registers and the values they currently contain. If we run that here we can see that <code>r9</code> contains the full user input value (<code>0xa31</code> in hex if the user entered "1"). This is not what we want and will cause unexpected behavior, we want one byte to be read at a time and we do not want the line feed byte to be included.</p>
<p>The <code>mov</code> instruction in nasm will move the entire value from the source into the destination. We can replace it with a more specific move instruction, <code>movzx</code>, and specify that we only want to move a byte. Our move instruction will now look like:</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>movzx r9, byte [read_buffer + r10]</span></span></code></pre>
<p>The "zx" portion of the instruction stands for "zero extend". A single byte will be moved and any remaining space will be filled with zeros to "extend" it to be a word.</p>
<h2 id="add-our-numbers-together">Add our numbers together</h2>
<p>After we have two numbers, adding them together is a simple task. We will use a variable to store our sum.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>section .data</span></span>
<span class="giallo-l"><span>; ...</span></span>
<span class="giallo-l"><span>sum: dq 0</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>section .text</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>; Enter _start, prompt the user to enter a number, call _read which itself calls _read_buffer_to_number</span></span>
<span class="giallo-l"><span>; _read_buffer_to_number leaves our user input number in r12</span></span>
<span class="giallo-l"><span>add [sum], r12</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>; Repeat for the second input number</span></span></code></pre>
<p>Above, we are using a <code>sum</code> variable to store the sum of the user input numbers. It is initialized to be 0 and then both times a number is entered, that numer is added to <code>sum</code>. The brackets in the <code>add</code> instruction act to dereference the variable and add to the value it holds.</p>
<h2 id="convert-our-sum-into-a-string">Convert our sum into a string</h2>
<p>Once we have our sum, the number must be converted into a string so it can be displayed to the user.</p>
<pre class="giallo" style="color: #E6E6E6; background-color: #222222;"><code data-lang="plain"><span class="giallo-l"><span>_int_to_string:</span></span>
<span class="giallo-l"><span>    ; Function prologue</span></span>
<span class="giallo-l"><span>    push rbp</span></span>
<span class="giallo-l"><span>    mov rbp, rsp</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Input is in r12</span></span>
<span class="giallo-l"><span>    mov r10, 0 ; Loop counter</span></span>
<span class="giallo-l"><span>    .div_loop:</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        mov rax, r12 ; Move the lower 32 bits of the dividend into rax</span></span>
<span class="giallo-l"><span>        mov rdx, 0 ; Clear RDX (0 out the upper 32 bits of the dividend)</span></span>
<span class="giallo-l"><span>        mov rbx, 10 ; Move the divisor into rbx</span></span>
<span class="giallo-l"><span>        div rbx ; Divide rdx:rax by rbx</span></span>
<span class="giallo-l"><span>        mov r12, rax ; Replace r12 with the quotient</span></span>
<span class="giallo-l"><span>        mov r11, rdx ; Place our remainder in r11</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>        add r11, 48 ; Convert our int into an ASCII number</span></span>
<span class="giallo-l"><span>        push r11 ; Push our digit onto the stack. We push/pop the digits so our string reads in the correct order</span></span>
<span class="giallo-l"><span>        add r10, 1 ; increment counter</span></span>
<span class="giallo-l"><span>        ; If r12 is greater than 0 then we still have more digits to read</span></span>
<span class="giallo-l"><span>        cmp r12, 0</span></span>
<span class="giallo-l"><span>        jg .div_loop</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Pop the digits off of the stack</span></span>
<span class="giallo-l"><span>    mov r11, 0 ; Second loop counter</span></span>
<span class="giallo-l"><span>    .pop_loop:</span></span>
<span class="giallo-l"><span>        pop r13</span></span>
<span class="giallo-l"><span>        mov [read_buffer + r11], r13b ; Move the least significant byte from r13 into the read buffer</span></span>
<span class="giallo-l"><span>        add r11, 1 ; increment counter</span></span>
<span class="giallo-l"><span>        cmp r11, r10 ; compare the loop counter against the number of digits that were stored on the stack</span></span>
<span class="giallo-l"><span>        jl .pop_loop ; If our loop counter is smaller, we have more digits to pop</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Add a line feed to read_buffer</span></span>
<span class="giallo-l"><span>    mov [read_buffer + r11], byte 10</span></span>
<span class="giallo-l"><span>    add r10, 1 ; Increment the number of characters we wrote by one to account for the line feed</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Set r12 to be our string output</span></span>
<span class="giallo-l"><span>    mov r12, read_buffer</span></span>
<span class="giallo-l"><span>    ; Set r13 to be the number of characters we wrote to the string</span></span>
<span class="giallo-l"><span>    mov r13, r10</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>    ; Function epilogue</span></span>
<span class="giallo-l"><span>    mov rsp, rbp</span></span>
<span class="giallo-l"><span>    pop rbp</span></span>
<span class="giallo-l"><span>    ret</span></span></code></pre>
<p>This function takes a number as an input in the <code>r12</code> register. The first loop divides the value in <code>r12</code> by 10 to pop off the rightmost digit, converts it to an ASCII representation, and then pushes it onto the stack. If our remaining value is greater than 0, then we still have digits to read and the loop repeats. The second loop pops our ASCII digits off of the stack and into our string buffer. A line feed is then added and we return our string in the <code>r12</code> register and its length in the <code>r13</code> register (the string is also "returned" into the buffer).</p>
<p>The process of pushing and then popping our digits to and from the stack ensures that the number is built in the correct order. The first loop, which gets each digit and converts them, reads the digits from back to front. This causes our number to appear backwards. Since the stack is LIFO, pushing our digits to the stack as we read them and then taking the digits out when we are building the string will reverse their order into being correct.</p>
<p>After running this function, the <code>r12</code> and <code>r13</code> registers contain our string and its length. Supplying these for a <code>std_write</code> syscall finishes our program and displays the result to the user.</p>
<h2 id="running-the-program">Running the program</h2>
<p>The adding program now works, with some limitations. It cannot add negative numbers or non-whole numbers, we would need to check for "-" and "." ASCII characters and handle them accordingly.</p>
<p><img src="https://kyleoneill.dev/blog/learning-x86-64/add.png" alt="add_program_result_image" /></p>
<h2 id="epilogue">Epilogue</h2>
<p>I began this program with the intent on just adding two numbers together but ended up spending all of my time writing it on type conversion. Working without a standard library shows how convenient it is that most languages come with the batteries included and you don't need to worry about converting a string to a number beyond <code>my_string.parse::&lt;i32&gt;()</code>.</p>

</div>
<div class="section navigation">
    
    
</div>

        <div class="section footer">
            &copy; 2026 Kyle O&#x27;Neill
        </div>
    </body>
</html>
